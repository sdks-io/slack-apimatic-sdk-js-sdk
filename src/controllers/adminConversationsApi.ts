/**
 * Slack Web APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core.js';
import {
  AdminConversationsArchiveSchema,
  adminConversationsArchiveSchemaSchema,
} from '../models/adminConversationsArchiveSchema.js';
import {
  AdminConversationsConvertToPrivateSchema,
  adminConversationsConvertToPrivateSchemaSchema,
} from '../models/adminConversationsConvertToPrivateSchema.js';
import {
  AdminConversationsCreateSchema,
  adminConversationsCreateSchemaSchema,
} from '../models/adminConversationsCreateSchema.js';
import {
  AdminConversationsDeleteSchema,
  adminConversationsDeleteSchemaSchema,
} from '../models/adminConversationsDeleteSchema.js';
import {
  AdminConversationsGetConversationPrefsSchema,
  adminConversationsGetConversationPrefsSchemaSchema,
} from '../models/adminConversationsGetConversationPrefsSchema.js';
import {
  AdminConversationsGetTeamsSchema,
  adminConversationsGetTeamsSchemaSchema,
} from '../models/adminConversationsGetTeamsSchema.js';
import {
  AdminConversationsInviteSchema,
  adminConversationsInviteSchemaSchema,
} from '../models/adminConversationsInviteSchema.js';
import {
  AdminConversationsRenameSchema,
  adminConversationsRenameSchemaSchema,
} from '../models/adminConversationsRenameSchema.js';
import {
  AdminConversationsRenameSchema1,
  adminConversationsRenameSchema1Schema,
} from '../models/adminConversationsRenameSchema1.js';
import {
  AdminConversationsSearchSchema,
  adminConversationsSearchSchemaSchema,
} from '../models/adminConversationsSearchSchema.js';
import {
  AdminConversationsSetConversationPrefsSchema,
  adminConversationsSetConversationPrefsSchemaSchema,
} from '../models/adminConversationsSetConversationPrefsSchema.js';
import {
  AdminConversationsUnarchiveSchema,
  adminConversationsUnarchiveSchemaSchema,
} from '../models/adminConversationsUnarchiveSchema.js';
import {
  DefaultSuccessTemplate,
  defaultSuccessTemplateSchema,
} from '../models/defaultSuccessTemplate.js';
import { boolean, number, optional, string } from '../schema.js';
import { BaseApi } from './baseApi.js';
import { AdminConversationsArchiveErrorSchemaError } from '../errors/adminConversationsArchiveErrorSchemaError.js';
import { AdminConversationsConvertToPrivateErrorSchemaError } from '../errors/adminConversationsConvertToPrivateErrorSchemaError.js';
import { AdminConversationsCreateErrorSchemaError } from '../errors/adminConversationsCreateErrorSchemaError.js';
import { AdminConversationsDeleteErrorSchemaError } from '../errors/adminConversationsDeleteErrorSchemaError.js';
import { AdminConversationsDisconnectSharedErrorSchemaError } from '../errors/adminConversationsDisconnectSharedErrorSchemaError.js';
import { AdminConversationsGetTeamsErrorSchemaError } from '../errors/adminConversationsGetTeamsErrorSchemaError.js';
import { AdminConversationsInviteErrorSchemaError } from '../errors/adminConversationsInviteErrorSchemaError.js';
import { AdminConversationsSearchErrorSchemaError } from '../errors/adminConversationsSearchErrorSchemaError.js';
import { AdminConversationsSetConversationPrefsErrorSchemaError } from '../errors/adminConversationsSetConversationPrefsErrorSchemaError.js';
import { AdminConversationsUnarchiveErrorSchema2Error } from '../errors/adminConversationsUnarchiveErrorSchema2Error.js';
import { AdminConversationsUnarchiveErrorSchema3Error } from '../errors/adminConversationsUnarchiveErrorSchema3Error.js';
import { AdminConversationsUnarchiveErrorSchemaError } from '../errors/adminConversationsUnarchiveErrorSchemaError.js';
import { DefaultErrorTemplateError } from '../errors/defaultErrorTemplateError.js';

export class AdminConversationsApi extends BaseApi {
  /**
   * Archive a public or private channel.
   *
   * @param token        Authentication token. Requires scope: `admin.conversations:write`
   * @param channelId    The channel to archive.
   * @return Response from the API call
   */
  async adminConversationsArchive(
    token: string,
    channelId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminConversationsArchiveSchema>> {
    const req = this.createRequest('POST', '/admin.conversations.archive');
    const mapped = req.prepareArgs({
      token: [token, string()],
      channelId: [channelId, string()],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({ channel_id: mapped.channelId });
    req.defaultToError(
      AdminConversationsArchiveErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      adminConversationsArchiveSchemaSchema,
      requestOptions
    );
  }

  /**
   * Convert a public channel to a private channel.
   *
   * @param token        Authentication token. Requires scope: `admin.conversations:write`
   * @param channelId    The channel to convert to private.
   * @return Response from the API call
   */
  async adminConversationsConvertToPrivate(
    token: string,
    channelId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminConversationsConvertToPrivateSchema>> {
    const req = this.createRequest(
      'POST',
      '/admin.conversations.convertToPrivate'
    );
    const mapped = req.prepareArgs({
      token: [token, string()],
      channelId: [channelId, string()],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({ channel_id: mapped.channelId });
    req.defaultToError(
      AdminConversationsConvertToPrivateErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      adminConversationsConvertToPrivateSchemaSchema,
      requestOptions
    );
  }

  /**
   * Create a public or private channel-based conversation.
   *
   * @param token        Authentication token. Requires scope: `admin.conversations:write`
   * @param name         Name of the public or private channel to create.
   * @param isPrivate    When `true`, creates a private channel instead of a public channel
   * @param description  Description of the public or private channel to create.
   * @param orgWide      When `true`, the channel will be available org-wide. Note: if the channel is not
   *                                `org_wide=true`, you must specify a `team_id` for this channel
   * @param teamId       The workspace to create the channel in. Note: this argument is required unless you
   *                                set `org_wide=true`.
   * @return Response from the API call
   */
  async adminConversationsCreate(
    token: string,
    name: string,
    isPrivate: boolean,
    description?: string,
    orgWide?: boolean,
    teamId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminConversationsCreateSchema>> {
    const req = this.createRequest('POST', '/admin.conversations.create');
    const mapped = req.prepareArgs({
      token: [token, string()],
      name: [name, string()],
      isPrivate: [isPrivate, boolean()],
      description: [description, optional(string())],
      orgWide: [orgWide, optional(boolean())],
      teamId: [teamId, optional(string())],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({
      name: mapped.name,
      is_private: mapped.isPrivate,
      description: mapped.description,
      org_wide: mapped.orgWide,
      team_id: mapped.teamId,
    });
    req.defaultToError(
      AdminConversationsCreateErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(adminConversationsCreateSchemaSchema, requestOptions);
  }

  /**
   * Delete a public or private channel.
   *
   * @param token        Authentication token. Requires scope: `admin.conversations:write`
   * @param channelId    The channel to delete.
   * @return Response from the API call
   */
  async adminConversationsDelete(
    token: string,
    channelId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminConversationsDeleteSchema>> {
    const req = this.createRequest('POST', '/admin.conversations.delete');
    const mapped = req.prepareArgs({
      token: [token, string()],
      channelId: [channelId, string()],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({ channel_id: mapped.channelId });
    req.defaultToError(
      AdminConversationsDeleteErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(adminConversationsDeleteSchemaSchema, requestOptions);
  }

  /**
   * Disconnect a connected channel from one or more workspaces.
   *
   * @param token            Authentication token. Requires scope: `admin.conversations:write`
   * @param channelId        The channel to be disconnected from some workspaces.
   * @param leavingTeamIds   The team to be removed from the channel. Currently only a single team id can be
   *                                   specified.
   * @return Response from the API call
   */
  async adminConversationsDisconnectShared(
    token: string,
    channelId: string,
    leavingTeamIds?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminConversationsRenameSchema>> {
    const req = this.createRequest(
      'POST',
      '/admin.conversations.disconnectShared'
    );
    const mapped = req.prepareArgs({
      token: [token, string()],
      channelId: [channelId, string()],
      leavingTeamIds: [leavingTeamIds, optional(string())],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({
      channel_id: mapped.channelId,
      leaving_team_ids: mapped.leavingTeamIds,
    });
    req.defaultToError(
      AdminConversationsDisconnectSharedErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(adminConversationsRenameSchemaSchema, requestOptions);
  }

  /**
   * Get conversation preferences for a public or private channel.
   *
   * @param token        Authentication token. Requires scope: `admin.conversations:read`
   * @param channelId    The channel to get preferences for.
   * @return Response from the API call
   */
  async adminConversationsGetConversationPrefs(
    token: string,
    channelId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminConversationsGetConversationPrefsSchema>> {
    const req = this.createRequest(
      'GET',
      '/admin.conversations.getConversationPrefs'
    );
    const mapped = req.prepareArgs({
      token: [token, string()],
      channelId: [channelId, string()],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.query('channel_id', mapped.channelId);
    req.defaultToError(
      AdminConversationsUnarchiveErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      adminConversationsGetConversationPrefsSchemaSchema,
      requestOptions
    );
  }

  /**
   * Get all the workspaces a given public or private channel is connected to within this Enterprise org.
   *
   * @param token        Authentication token. Requires scope: `admin.conversations:read`
   * @param channelId    The channel to determine connected workspaces within the organization for.
   * @param cursor       Set `cursor` to `next_cursor` returned by the previous call to list items in the
   *                               next page
   * @param limit        The maximum number of items to return. Must be between 1 - 1000 both inclusive.
   * @return Response from the API call
   */
  async adminConversationsGetTeams(
    token: string,
    channelId: string,
    cursor?: string,
    limit?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminConversationsGetTeamsSchema>> {
    const req = this.createRequest('GET', '/admin.conversations.getTeams');
    const mapped = req.prepareArgs({
      token: [token, string()],
      channelId: [channelId, string()],
      cursor: [cursor, optional(string())],
      limit: [limit, optional(number())],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.query('channel_id', mapped.channelId);
    req.query('cursor', mapped.cursor);
    req.query('limit', mapped.limit);
    req.defaultToError(
      AdminConversationsGetTeamsErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      adminConversationsGetTeamsSchemaSchema,
      requestOptions
    );
  }

  /**
   * Invite a user to a public or private channel.
   *
   * @param token        Authentication token. Requires scope: `admin.conversations:write`
   * @param userIds      The users to invite.
   * @param channelId    The channel that the users will be invited to.
   * @return Response from the API call
   */
  async adminConversationsInvite(
    token: string,
    userIds: string,
    channelId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminConversationsInviteSchema>> {
    const req = this.createRequest('POST', '/admin.conversations.invite');
    const mapped = req.prepareArgs({
      token: [token, string()],
      userIds: [userIds, string()],
      channelId: [channelId, string()],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({ user_ids: mapped.userIds, channel_id: mapped.channelId });
    req.defaultToError(
      AdminConversationsInviteErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(adminConversationsInviteSchemaSchema, requestOptions);
  }

  /**
   * Rename a public or private channel.
   *
   * @param token        Authentication token. Requires scope: `admin.conversations:write`
   * @param channelId    The channel to rename.
   * @param name
   * @return Response from the API call
   */
  async adminConversationsRename(
    token: string,
    channelId: string,
    name: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminConversationsRenameSchema1>> {
    const req = this.createRequest('POST', '/admin.conversations.rename');
    const mapped = req.prepareArgs({
      token: [token, string()],
      channelId: [channelId, string()],
      name: [name, string()],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({ channel_id: mapped.channelId, name: mapped.name });
    req.defaultToError(
      AdminConversationsUnarchiveErrorSchema2Error,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      adminConversationsRenameSchema1Schema,
      requestOptions
    );
  }

  /**
   * Search for public or private channels in an Enterprise organization.
   *
   * @param token                Authentication token. Requires scope: `admin.conversations:read`
   * @param teamIds              Comma separated string of team IDs, signifying the workspaces to search
   *                                       through.
   * @param query                Name of the the channel to query by.
   * @param limit                Maximum number of items to be returned. Must be between 1 - 20 both
   *                                       inclusive. Default is 10.
   * @param cursor               Set `cursor` to `next_cursor` returned by the previous call to list items
   *                                       in the next page.
   * @param searchChannelTypes   The type of channel to include or exclude in the search. For example
   *                                       `private` will search private channels, while `private_exclude` will exclude
   *                                       them. For a full list of types, check the [Types section](#types).
   * @param sort                 Possible values are `relevant` (search ranking based on what we think is
   *                                       closest), `name` (alphabetical), `member_count` (number of users in the
   *                                       channel), and `created` (date channel was created). You can optionally pair
   *                                       this with the `sort_dir` arg to change how it is sorted
   * @param sortDir              Sort direction. Possible values are `asc` for ascending order like (1, 2,
   *                                       3) or (a, b, c), and `desc` for descending order like (3, 2, 1) or (c, b,
   *                                       a)
   * @return Response from the API call
   */
  async adminConversationsSearch(
    token: string,
    teamIds?: string,
    query?: string,
    limit?: number,
    cursor?: string,
    searchChannelTypes?: string,
    sort?: string,
    sortDir?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminConversationsSearchSchema>> {
    const req = this.createRequest('GET', '/admin.conversations.search');
    const mapped = req.prepareArgs({
      token: [token, string()],
      teamIds: [teamIds, optional(string())],
      query: [query, optional(string())],
      limit: [limit, optional(number())],
      cursor: [cursor, optional(string())],
      searchChannelTypes: [searchChannelTypes, optional(string())],
      sort: [sort, optional(string())],
      sortDir: [sortDir, optional(string())],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.query('team_ids', mapped.teamIds);
    req.query('query', mapped.query);
    req.query('limit', mapped.limit);
    req.query('cursor', mapped.cursor);
    req.query('search_channel_types', mapped.searchChannelTypes);
    req.query('sort', mapped.sort);
    req.query('sort_dir', mapped.sortDir);
    req.defaultToError(
      AdminConversationsSearchErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(adminConversationsSearchSchemaSchema, requestOptions);
  }

  /**
   * Set the posting permissions for a public or private channel.
   *
   * @param token        Authentication token. Requires scope: `admin.conversations:write`
   * @param channelId    The channel to set the prefs for
   * @param prefs        The prefs for this channel in a stringified JSON format.
   * @return Response from the API call
   */
  async adminConversationsSetConversationPrefs(
    token: string,
    channelId: string,
    prefs: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminConversationsSetConversationPrefsSchema>> {
    const req = this.createRequest(
      'POST',
      '/admin.conversations.setConversationPrefs'
    );
    const mapped = req.prepareArgs({
      token: [token, string()],
      channelId: [channelId, string()],
      prefs: [prefs, string()],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({ channel_id: mapped.channelId, prefs: mapped.prefs });
    req.defaultToError(
      AdminConversationsSetConversationPrefsErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      adminConversationsSetConversationPrefsSchemaSchema,
      requestOptions
    );
  }

  /**
   * Set the workspaces in an Enterprise grid org that connect to a public or private channel.
   *
   * @param token           Authentication token. Requires scope: `admin.conversations:write`
   * @param channelId       The encoded `channel_id` to add or remove to workspaces.
   * @param teamId          The workspace to which the channel belongs. Omit this argument if the channel
   *                                   is a cross-workspace shared channel.
   * @param targetTeamIds   A comma-separated list of workspaces to which the channel should be shared. Not
   *                                   required if the channel is being shared org-wide.
   * @param orgChannel      True if channel has to be converted to an org channel
   * @return Response from the API call
   */
  async adminConversationsSetTeams(
    token: string,
    channelId: string,
    teamId?: string,
    targetTeamIds?: string,
    orgChannel?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<DefaultSuccessTemplate>> {
    const req = this.createRequest('POST', '/admin.conversations.setTeams');
    const mapped = req.prepareArgs({
      token: [token, string()],
      channelId: [channelId, string()],
      teamId: [teamId, optional(string())],
      targetTeamIds: [targetTeamIds, optional(string())],
      orgChannel: [orgChannel, optional(boolean())],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({
      channel_id: mapped.channelId,
      team_id: mapped.teamId,
      target_team_ids: mapped.targetTeamIds,
      org_channel: mapped.orgChannel,
    });
    req.defaultToError(DefaultErrorTemplateError, 'Typical error response');
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(defaultSuccessTemplateSchema, requestOptions);
  }

  /**
   * Unarchive a public or private channel.
   *
   * @param token        Authentication token. Requires scope: `admin.conversations:write`
   * @param channelId    The channel to unarchive.
   * @return Response from the API call
   */
  async adminConversationsUnarchive(
    token: string,
    channelId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminConversationsUnarchiveSchema>> {
    const req = this.createRequest('POST', '/admin.conversations.unarchive');
    const mapped = req.prepareArgs({
      token: [token, string()],
      channelId: [channelId, string()],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({ channel_id: mapped.channelId });
    req.defaultToError(
      AdminConversationsUnarchiveErrorSchema3Error,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      adminConversationsUnarchiveSchemaSchema,
      requestOptions
    );
  }
}
