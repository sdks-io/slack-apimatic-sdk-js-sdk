/**
 * Slack Web APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core.js';
import {
  DefaultSuccessTemplate,
  defaultSuccessTemplateSchema,
} from '../models/defaultSuccessTemplate.js';
import { optional, string } from '../schema.js';
import { BaseApi } from './baseApi.js';
import { DefaultErrorTemplateError } from '../errors/defaultErrorTemplateError.js';

export class ViewsApi extends BaseApi {
  /**
   * Open a view for a user.
   *
   * @param token        Authentication token. Requires scope: `none`
   * @param triggerId    Exchange a trigger to post to the user.
   * @param view         A [view payload](/reference/surfaces/views). This must be a JSON-encoded string.
   * @return Response from the API call
   */
  async viewsOpen(
    token: string,
    triggerId: string,
    view: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<DefaultSuccessTemplate>> {
    const req = this.createRequest('GET', '/views.open');
    const mapped = req.prepareArgs({
      token: [token, string()],
      triggerId: [triggerId, string()],
      view: [view, string()],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.query('trigger_id', mapped.triggerId);
    req.query('view', mapped.view);
    req.defaultToError(
      DefaultErrorTemplateError,
      'Typical error response, before getting to any possible validation errors.'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(defaultSuccessTemplateSchema, requestOptions);
  }

  /**
   * Publish a static view for a User.
   *
   * @param token        Authentication token. Requires scope: `none`
   * @param userId       `id` of the user you want publish a view to.
   * @param view         A [view payload](/reference/surfaces/views). This must be a JSON-encoded string.
   * @param hash         A string that represents view state to protect against possible race conditions.
   * @return Response from the API call
   */
  async viewsPublish(
    token: string,
    userId: string,
    view: string,
    hash?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<DefaultSuccessTemplate>> {
    const req = this.createRequest('GET', '/views.publish');
    const mapped = req.prepareArgs({
      token: [token, string()],
      userId: [userId, string()],
      view: [view, string()],
      hash: [hash, optional(string())],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.query('user_id', mapped.userId);
    req.query('view', mapped.view);
    req.query('hash', mapped.hash);
    req.defaultToError(
      DefaultErrorTemplateError,
      'Typical error response, before getting to any possible validation errors.'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(defaultSuccessTemplateSchema, requestOptions);
  }

  /**
   * Push a view onto the stack of a root view.
   *
   * @param token        Authentication token. Requires scope: `none`
   * @param triggerId    Exchange a trigger to post to the user.
   * @param view         A [view payload](/reference/surfaces/views). This must be a JSON-encoded string.
   * @return Response from the API call
   */
  async viewsPush(
    token: string,
    triggerId: string,
    view: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<DefaultSuccessTemplate>> {
    const req = this.createRequest('GET', '/views.push');
    const mapped = req.prepareArgs({
      token: [token, string()],
      triggerId: [triggerId, string()],
      view: [view, string()],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.query('trigger_id', mapped.triggerId);
    req.query('view', mapped.view);
    req.defaultToError(DefaultErrorTemplateError, 'Typical error response.');
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(defaultSuccessTemplateSchema, requestOptions);
  }

  /**
   * Update an existing view.
   *
   * @param token        Authentication token. Requires scope: `none`
   * @param viewId       A unique identifier of the view to be updated. Either `view_id` or `external_id` is
   *                               required.
   * @param externalId   A unique identifier of the view set by the developer. Must be unique for all views
   *                               on a team. Max length of 255 characters. Either `view_id` or `external_id` is
   *                               required.
   * @param view         A [view object](/reference/surfaces/views). This must be a JSON-encoded string.
   * @param hash         A string that represents view state to protect against possible race conditions.
   * @return Response from the API call
   */
  async viewsUpdate(
    token: string,
    viewId?: string,
    externalId?: string,
    view?: string,
    hash?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<DefaultSuccessTemplate>> {
    const req = this.createRequest('GET', '/views.update');
    const mapped = req.prepareArgs({
      token: [token, string()],
      viewId: [viewId, optional(string())],
      externalId: [externalId, optional(string())],
      view: [view, optional(string())],
      hash: [hash, optional(string())],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.query('view_id', mapped.viewId);
    req.query('external_id', mapped.externalId);
    req.query('view', mapped.view);
    req.query('hash', mapped.hash);
    req.defaultToError(DefaultErrorTemplateError, 'Typical error response.');
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(defaultSuccessTemplateSchema, requestOptions);
  }
}
