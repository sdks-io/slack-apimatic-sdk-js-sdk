/**
 * Slack Web APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core.js';
import {
  ChatDeleteScheduledMessageSchema,
  chatDeleteScheduledMessageSchemaSchema,
} from '../models/chatDeleteScheduledMessageSchema.js';
import {
  ChatDeleteSuccessSchema,
  chatDeleteSuccessSchemaSchema,
} from '../models/chatDeleteSuccessSchema.js';
import {
  ChatGetPermalinkSuccessSchema,
  chatGetPermalinkSuccessSchemaSchema,
} from '../models/chatGetPermalinkSuccessSchema.js';
import {
  ChatMeMessageSchema,
  chatMeMessageSchemaSchema,
} from '../models/chatMeMessageSchema.js';
import {
  ChatPostEphemeralSuccessSchema,
  chatPostEphemeralSuccessSchemaSchema,
} from '../models/chatPostEphemeralSuccessSchema.js';
import {
  ChatPostMessageSuccessSchema,
  chatPostMessageSuccessSchemaSchema,
} from '../models/chatPostMessageSuccessSchema.js';
import {
  ChatScheduleMessageSuccessSchema,
  chatScheduleMessageSuccessSchemaSchema,
} from '../models/chatScheduleMessageSuccessSchema.js';
import {
  ChatUnfurlSuccessSchema,
  chatUnfurlSuccessSchemaSchema,
} from '../models/chatUnfurlSuccessSchema.js';
import {
  ChatUpdateSuccessSchema,
  chatUpdateSuccessSchemaSchema,
} from '../models/chatUpdateSuccessSchema.js';
import { boolean, number, optional, string } from '../schema.js';
import { BaseApi } from './baseApi.js';
import { ChatDeleteErrorSchemaError } from '../errors/chatDeleteErrorSchemaError.js';
import { ChatDeleteScheduledMessageErrorSchemaError } from '../errors/chatDeleteScheduledMessageErrorSchemaError.js';
import { ChatGetPermalinkErrorSchemaError } from '../errors/chatGetPermalinkErrorSchemaError.js';
import { ChatMeMessageErrorSchemaError } from '../errors/chatMeMessageErrorSchemaError.js';
import { ChatPostEphemeralErrorSchemaError } from '../errors/chatPostEphemeralErrorSchemaError.js';
import { ChatPostMessageErrorSchemaError } from '../errors/chatPostMessageErrorSchemaError.js';
import { ChatScheduleMessageErrorSchemaError } from '../errors/chatScheduleMessageErrorSchemaError.js';
import { ChatUnfurlErrorSchemaError } from '../errors/chatUnfurlErrorSchemaError.js';
import { ChatUpdateErrorSchemaError } from '../errors/chatUpdateErrorSchemaError.js';

export class ChatApi extends BaseApi {
  /**
   * Deletes a message.
   *
   * @param token        Authentication token. Requires scope: `chat:write`
   * @param ts           Timestamp of the message to be deleted.
   * @param channel      Channel containing the message to be deleted.
   * @param asUser       Pass true to delete the message as the authed user with `chat:write:user` scope.
   *                                [Bot users](/bot-users) in this context are considered authed users. If unused or
   *                                false, the message will be deleted with `chat:write:bot` scope.
   * @return Response from the API call
   */
  async chatDelete(
    token?: string,
    ts?: number,
    channel?: string,
    asUser?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ChatDeleteSuccessSchema>> {
    const req = this.createRequest('POST', '/chat.delete');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      ts: [ts, optional(number())],
      channel: [channel, optional(string())],
      asUser: [asUser, optional(boolean())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({
      ts: mapped.ts,
      channel: mapped.channel,
      as_user: mapped.asUser,
    });
    req.defaultToError(ChatDeleteErrorSchemaError, 'Typical error response');
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(chatDeleteSuccessSchemaSchema, requestOptions);
  }

  /**
   * Deletes a pending scheduled message from the queue.
   *
   * @param token                Authentication token. Requires scope: `chat:write`
   * @param channel              The channel the scheduled_message is posting to
   * @param scheduledMessageId   `scheduled_message_id` returned from call to chat.scheduleMessage
   * @param asUser               Pass true to delete the message as the authed user with `chat:write:user`
   *                                        scope. [Bot users](/bot-users) in this context are considered authed users.
   *                                        If unused or false, the message will be deleted with `chat:write:bot` scope.
   * @return Response from the API call
   */
  async chatDeleteScheduledMessage(
    token: string,
    channel: string,
    scheduledMessageId: string,
    asUser?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ChatDeleteScheduledMessageSchema>> {
    const req = this.createRequest('POST', '/chat.deleteScheduledMessage');
    const mapped = req.prepareArgs({
      token: [token, string()],
      channel: [channel, string()],
      scheduledMessageId: [scheduledMessageId, string()],
      asUser: [asUser, optional(boolean())],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({
      channel: mapped.channel,
      scheduled_message_id: mapped.scheduledMessageId,
      as_user: mapped.asUser,
    });
    req.defaultToError(
      ChatDeleteScheduledMessageErrorSchemaError,
      'Typical error response if no message is found'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      chatDeleteScheduledMessageSchemaSchema,
      requestOptions
    );
  }

  /**
   * Retrieve a permalink URL for a specific extant message
   *
   * @param token        Authentication token. Requires scope: `none`
   * @param channel      The ID of the conversation or channel containing the message
   * @param messageTs    A message's `ts` value, uniquely identifying it within a channel
   * @return Response from the API call
   */
  async chatGetPermalink(
    token: string,
    channel: string,
    messageTs: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ChatGetPermalinkSuccessSchema>> {
    const req = this.createRequest('GET', '/chat.getPermalink');
    const mapped = req.prepareArgs({
      token: [token, string()],
      channel: [channel, string()],
      messageTs: [messageTs, string()],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.query('token', mapped.token);
    req.query('channel', mapped.channel);
    req.query('message_ts', mapped.messageTs);
    req.defaultToError(
      ChatGetPermalinkErrorSchemaError,
      'Error response when channel cannot be found'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(chatGetPermalinkSuccessSchemaSchema, requestOptions);
  }

  /**
   * Share a me message into a channel.
   *
   * @param token        Authentication token. Requires scope: `chat:write`
   * @param channel      Channel to send message to. Can be a public channel, private group or IM channel.
   *                               Can be an encoded ID, or a name.
   * @param text         Text of the message to send.
   * @return Response from the API call
   */
  async chatMeMessage(
    token?: string,
    channel?: string,
    text?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ChatMeMessageSchema>> {
    const req = this.createRequest('POST', '/chat.meMessage');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
      text: [text, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({ channel: mapped.channel, text: mapped.text });
    req.defaultToError(ChatMeMessageErrorSchemaError, 'Typical error response');
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(chatMeMessageSchemaSchema, requestOptions);
  }

  /**
   * Sends an ephemeral message to a user in a channel.
   *
   * @param token        Authentication token. Requires scope: `chat:write`
   * @param channel      Channel, private group, or IM channel to send message to. Can be an encoded ID, or
   *                                a name.
   * @param user         `id` of the user who will receive the ephemeral message. The user should be in the
   *                                channel specified by the `channel` argument.
   * @param asUser       Pass true to post the message as the authed user. Defaults to true if the chat:
   *                                write:bot scope is not included. Otherwise, defaults to false.
   * @param attachments  A JSON-based array of structured attachments, presented as a URL-encoded string.
   * @param blocks       A JSON-based array of structured blocks, presented as a URL-encoded string.
   * @param iconEmoji    Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in
   *                                conjunction with `as_user` set to `false`, otherwise ignored. See
   *                                [authorship](#authorship) below.
   * @param iconUrl      URL to an image to use as the icon for this message. Must be used in conjunction
   *                                with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
   * @param linkNames    Find and link channel names and usernames.
   * @param parse        Change how messages are treated. Defaults to `none`. See [below](#formatting).
   * @param text         How this field works and whether it is required depends on other fields you use in
   *                                your API call. [See below](#text_usage) for more detail.
   * @param threadTs     Provide another message's `ts` value to post this message in a thread. Avoid using
   *                                a reply's `ts` value; use its parent's value instead. Ephemeral messages in threads
   *                                are only shown if there is already an active thread.
   * @param username     Set your bot's user name. Must be used in conjunction with `as_user` set to false,
   *                                otherwise ignored. See [authorship](#authorship) below.
   * @return Response from the API call
   */
  async chatPostEphemeral(
    token: string,
    channel: string,
    user: string,
    asUser?: boolean,
    attachments?: string,
    blocks?: string,
    iconEmoji?: string,
    iconUrl?: string,
    linkNames?: boolean,
    parse?: string,
    text?: string,
    threadTs?: string,
    username?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ChatPostEphemeralSuccessSchema>> {
    const req = this.createRequest('POST', '/chat.postEphemeral');
    const mapped = req.prepareArgs({
      token: [token, string()],
      channel: [channel, string()],
      user: [user, string()],
      asUser: [asUser, optional(boolean())],
      attachments: [attachments, optional(string())],
      blocks: [blocks, optional(string())],
      iconEmoji: [iconEmoji, optional(string())],
      iconUrl: [iconUrl, optional(string())],
      linkNames: [linkNames, optional(boolean())],
      parse: [parse, optional(string())],
      text: [text, optional(string())],
      threadTs: [threadTs, optional(string())],
      username: [username, optional(string())],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({
      channel: mapped.channel,
      user: mapped.user,
      as_user: mapped.asUser,
      attachments: mapped.attachments,
      blocks: mapped.blocks,
      icon_emoji: mapped.iconEmoji,
      icon_url: mapped.iconUrl,
      link_names: mapped.linkNames,
      parse: mapped.parse,
      text: mapped.text,
      thread_ts: mapped.threadTs,
      username: mapped.username,
    });
    req.defaultToError(
      ChatPostEphemeralErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(chatPostEphemeralSuccessSchemaSchema, requestOptions);
  }

  /**
   * Sends a message to a channel.
   *
   * @param token           Authentication token. Requires scope: `chat:write`
   * @param channel         Channel, private group, or IM channel to send message to. Can be an encoded ID,
   *                                   or a name. See [below](#channels) for more details.
   * @param asUser          Pass true to post the message as the authed user, instead of as a bot. Defaults
   *                                   to false. See [authorship](#authorship) below.
   * @param attachments     A JSON-based array of structured attachments, presented as a URL-encoded string.
   * @param blocks          A JSON-based array of structured blocks, presented as a URL-encoded string.
   * @param iconEmoji       Emoji to use as the icon for this message. Overrides `icon_url`. Must be used
   *                                   in conjunction with `as_user` set to `false`, otherwise ignored. See
   *                                   [authorship](#authorship) below.
   * @param iconUrl         URL to an image to use as the icon for this message. Must be used in
   *                                   conjunction with `as_user` set to false, otherwise ignored. See
   *                                   [authorship](#authorship) below.
   * @param linkNames       Find and link channel names and usernames.
   * @param mrkdwn          Disable Slack markup parsing by setting to `false`. Enabled by default.
   * @param parse           Change how messages are treated. Defaults to `none`. See [below](#formatting).
   * @param replyBroadcast  Used in conjunction with `thread_ts` and indicates whether reply should be made
   *                                   visible to everyone in the channel or conversation. Defaults to `false`.
   * @param text            How this field works and whether it is required depends on other fields you use
   *                                   in your API call. [See below](#text_usage) for more detail.
   * @param threadTs        Provide another message's `ts` value to make this message a reply. Avoid using
   *                                   a reply's `ts` value; use its parent instead.
   * @param unfurlLinks     Pass true to enable unfurling of primarily text-based content.
   * @param unfurlMedia     Pass false to disable unfurling of media content.
   * @param username        Set your bot's user name. Must be used in conjunction with `as_user` set to
   *                                   false, otherwise ignored. See [authorship](#authorship) below.
   * @return Response from the API call
   */
  async chatPostMessage(
    token: string,
    channel: string,
    asUser?: string,
    attachments?: string,
    blocks?: string,
    iconEmoji?: string,
    iconUrl?: string,
    linkNames?: boolean,
    mrkdwn?: boolean,
    parse?: string,
    replyBroadcast?: boolean,
    text?: string,
    threadTs?: string,
    unfurlLinks?: boolean,
    unfurlMedia?: boolean,
    username?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ChatPostMessageSuccessSchema>> {
    const req = this.createRequest('POST', '/chat.postMessage');
    const mapped = req.prepareArgs({
      token: [token, string()],
      channel: [channel, string()],
      asUser: [asUser, optional(string())],
      attachments: [attachments, optional(string())],
      blocks: [blocks, optional(string())],
      iconEmoji: [iconEmoji, optional(string())],
      iconUrl: [iconUrl, optional(string())],
      linkNames: [linkNames, optional(boolean())],
      mrkdwn: [mrkdwn, optional(boolean())],
      parse: [parse, optional(string())],
      replyBroadcast: [replyBroadcast, optional(boolean())],
      text: [text, optional(string())],
      threadTs: [threadTs, optional(string())],
      unfurlLinks: [unfurlLinks, optional(boolean())],
      unfurlMedia: [unfurlMedia, optional(boolean())],
      username: [username, optional(string())],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({
      channel: mapped.channel,
      as_user: mapped.asUser,
      attachments: mapped.attachments,
      blocks: mapped.blocks,
      icon_emoji: mapped.iconEmoji,
      icon_url: mapped.iconUrl,
      link_names: mapped.linkNames,
      mrkdwn: mapped.mrkdwn,
      parse: mapped.parse,
      reply_broadcast: mapped.replyBroadcast,
      text: mapped.text,
      thread_ts: mapped.threadTs,
      unfurl_links: mapped.unfurlLinks,
      unfurl_media: mapped.unfurlMedia,
      username: mapped.username,
    });
    req.defaultToError(
      ChatPostMessageErrorSchemaError,
      'Typical error response if too many attachments are included'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(chatPostMessageSuccessSchemaSchema, requestOptions);
  }

  /**
   * Schedules a message to be sent to a channel.
   *
   * @param token           Authentication token. Requires scope: `chat:write`
   * @param channel         Channel, private group, or DM channel to send message to. Can be an encoded ID,
   *                                   or a name. See [below](#channels) for more details.
   * @param text            How this field works and whether it is required depends on other fields you use
   *                                   in your API call. [See below](#text_usage) for more detail.
   * @param postAt          Unix EPOCH timestamp of time in future to send the message.
   * @param parse           Change how messages are treated. Defaults to `none`. See [chat.
   *                                   postMessage](chat.postMessage#formatting).
   * @param asUser          Pass true to post the message as the authed user, instead of as a bot. Defaults
   *                                   to false. See [chat.postMessage](chat.postMessage#authorship).
   * @param linkNames       Find and link channel names and usernames.
   * @param attachments     A JSON-based array of structured attachments, presented as a URL-encoded string.
   * @param blocks          A JSON-based array of structured blocks, presented as a URL-encoded string.
   * @param unfurlLinks     Pass true to enable unfurling of primarily text-based content.
   * @param unfurlMedia     Pass false to disable unfurling of media content.
   * @param threadTs        Provide another message's `ts` value to make this message a reply. Avoid using
   *                                   a reply's `ts` value; use its parent instead.
   * @param replyBroadcast  Used in conjunction with `thread_ts` and indicates whether reply should be made
   *                                   visible to everyone in the channel or conversation. Defaults to `false`.
   * @return Response from the API call
   */
  async chatScheduleMessage(
    token?: string,
    channel?: string,
    text?: string,
    postAt?: string,
    parse?: string,
    asUser?: boolean,
    linkNames?: boolean,
    attachments?: string,
    blocks?: string,
    unfurlLinks?: boolean,
    unfurlMedia?: boolean,
    threadTs?: number,
    replyBroadcast?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ChatScheduleMessageSuccessSchema>> {
    const req = this.createRequest('POST', '/chat.scheduleMessage');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
      text: [text, optional(string())],
      postAt: [postAt, optional(string())],
      parse: [parse, optional(string())],
      asUser: [asUser, optional(boolean())],
      linkNames: [linkNames, optional(boolean())],
      attachments: [attachments, optional(string())],
      blocks: [blocks, optional(string())],
      unfurlLinks: [unfurlLinks, optional(boolean())],
      unfurlMedia: [unfurlMedia, optional(boolean())],
      threadTs: [threadTs, optional(number())],
      replyBroadcast: [replyBroadcast, optional(boolean())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({
      channel: mapped.channel,
      text: mapped.text,
      post_at: mapped.postAt,
      parse: mapped.parse,
      as_user: mapped.asUser,
      link_names: mapped.linkNames,
      attachments: mapped.attachments,
      blocks: mapped.blocks,
      unfurl_links: mapped.unfurlLinks,
      unfurl_media: mapped.unfurlMedia,
      thread_ts: mapped.threadTs,
      reply_broadcast: mapped.replyBroadcast,
    });
    req.defaultToError(
      ChatScheduleMessageErrorSchemaError,
      'Typical error response if the `post_at` is invalid (ex. in the past or too far into the future)'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      chatScheduleMessageSuccessSchemaSchema,
      requestOptions
    );
  }

  /**
   * Provide custom unfurl behavior for user-posted URLs
   *
   * @param token              Authentication token. Requires scope: `links:write`
   * @param channel            Channel ID of the message
   * @param ts                 Timestamp of the message to add unfurl behavior to.
   * @param unfurls            URL-encoded JSON map with keys set to URLs featured in the the message,
   *                                      pointing to their unfurl blocks or message attachments.
   * @param userAuthMessage    Provide a simply-formatted string to send as an ephemeral message to the
   *                                      user as invitation to authenticate further and enable full unfurling
   *                                      behavior
   * @param userAuthRequired   Set to `true` or `1` to indicate the user must install your Slack app to
   *                                      trigger unfurls for this domain
   * @param userAuthUrl        Send users to this custom URL where they will complete authentication in
   *                                      your app to fully trigger unfurling. Value should be properly URL-encoded.
   * @return Response from the API call
   */
  async chatUnfurl(
    token: string,
    channel: string,
    ts: string,
    unfurls?: string,
    userAuthMessage?: string,
    userAuthRequired?: boolean,
    userAuthUrl?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ChatUnfurlSuccessSchema>> {
    const req = this.createRequest('POST', '/chat.unfurl');
    const mapped = req.prepareArgs({
      token: [token, string()],
      channel: [channel, string()],
      ts: [ts, string()],
      unfurls: [unfurls, optional(string())],
      userAuthMessage: [userAuthMessage, optional(string())],
      userAuthRequired: [userAuthRequired, optional(boolean())],
      userAuthUrl: [userAuthUrl, optional(string())],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({
      channel: mapped.channel,
      ts: mapped.ts,
      unfurls: mapped.unfurls,
      user_auth_message: mapped.userAuthMessage,
      user_auth_required: mapped.userAuthRequired,
      user_auth_url: mapped.userAuthUrl,
    });
    req.defaultToError(ChatUnfurlErrorSchemaError, 'Typical error response');
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(chatUnfurlSuccessSchemaSchema, requestOptions);
  }

  /**
   * Updates a message.
   *
   * @param token        Authentication token. Requires scope: `chat:write`
   * @param channel      Channel containing the message to be updated.
   * @param ts           Timestamp of the message to be updated.
   * @param asUser       Pass true to update the message as the authed user. [Bot users](/bot-users) in this
   *                               context are considered authed users.
   * @param attachments  A JSON-based array of structured attachments, presented as a URL-encoded string.
   *                               This field is required when not presenting `text`. If you don't include this field,
   *                               the message's previous `attachments` will be retained. To remove previous
   *                               `attachments`, include an empty array for this field.
   * @param blocks       A JSON-based array of [structured blocks](/block-kit/building), presented as a URL-
   *                               encoded string. If you don't include this field, the message's previous `blocks`
   *                               will be retained. To remove previous `blocks`, include an empty array for this field.
   * @param linkNames    Find and link channel names and usernames. Defaults to `none`. If you do not
   *                               specify a value for this field, the original value set for the message will be
   *                               overwritten with the default, `none`.
   * @param parse        Change how messages are treated. Defaults to `client`, unlike `chat.postMessage`.
   *                               Accepts either `none` or `full`. If you do not specify a value for this field, the
   *                               original value set for the message will be overwritten with the default, `client`.
   * @param text         New text for the message, using the [default formatting
   *                               rules](/reference/surfaces/formatting). It's not required when presenting `blocks`
   *                               or `attachments`.
   * @return Response from the API call
   */
  async chatUpdate(
    token: string,
    channel: string,
    ts: string,
    asUser?: string,
    attachments?: string,
    blocks?: string,
    linkNames?: string,
    parse?: string,
    text?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ChatUpdateSuccessSchema>> {
    const req = this.createRequest('POST', '/chat.update');
    const mapped = req.prepareArgs({
      token: [token, string()],
      channel: [channel, string()],
      ts: [ts, string()],
      asUser: [asUser, optional(string())],
      attachments: [attachments, optional(string())],
      blocks: [blocks, optional(string())],
      linkNames: [linkNames, optional(string())],
      parse: [parse, optional(string())],
      text: [text, optional(string())],
    });
    req.header('token', mapped.token);
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.form({
      channel: mapped.channel,
      ts: mapped.ts,
      as_user: mapped.asUser,
      attachments: mapped.attachments,
      blocks: mapped.blocks,
      link_names: mapped.linkNames,
      parse: mapped.parse,
      text: mapped.text,
    });
    req.defaultToError(ChatUpdateErrorSchemaError, 'Typical error response');
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(chatUpdateSuccessSchemaSchema, requestOptions);
  }
}
