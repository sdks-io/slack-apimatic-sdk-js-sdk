/**
 * Slack Web APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core.js';
import {
  ConversationsArchiveSuccessSchema,
  conversationsArchiveSuccessSchemaSchema,
} from '../models/conversationsArchiveSuccessSchema.js';
import {
  ConversationsCloseSuccessSchema,
  conversationsCloseSuccessSchemaSchema,
} from '../models/conversationsCloseSuccessSchema.js';
import {
  ConversationsCreateSuccessSchema,
  conversationsCreateSuccessSchemaSchema,
} from '../models/conversationsCreateSuccessSchema.js';
import {
  ConversationsHistorySuccessSchema,
  conversationsHistorySuccessSchemaSchema,
} from '../models/conversationsHistorySuccessSchema.js';
import {
  ConversationsInfoSuccessSchema,
  conversationsInfoSuccessSchemaSchema,
} from '../models/conversationsInfoSuccessSchema.js';
import {
  ConversationsInviteErrorSchema,
  conversationsInviteErrorSchemaSchema,
} from '../models/conversationsInviteErrorSchema.js';
import {
  ConversationsJoinSuccessSchema,
  conversationsJoinSuccessSchemaSchema,
} from '../models/conversationsJoinSuccessSchema.js';
import {
  ConversationsKickSuccessSchema,
  conversationsKickSuccessSchemaSchema,
} from '../models/conversationsKickSuccessSchema.js';
import {
  ConversationsLeaveSuccessSchema,
  conversationsLeaveSuccessSchemaSchema,
} from '../models/conversationsLeaveSuccessSchema.js';
import {
  ConversationsListSuccessSchema,
  conversationsListSuccessSchemaSchema,
} from '../models/conversationsListSuccessSchema.js';
import {
  ConversationsMarkSuccessSchema,
  conversationsMarkSuccessSchemaSchema,
} from '../models/conversationsMarkSuccessSchema.js';
import {
  ConversationsMembersSuccessSchema,
  conversationsMembersSuccessSchemaSchema,
} from '../models/conversationsMembersSuccessSchema.js';
import {
  ConversationsOpenSuccessSchema,
  conversationsOpenSuccessSchemaSchema,
} from '../models/conversationsOpenSuccessSchema.js';
import {
  ConversationsRenameSuccessSchema,
  conversationsRenameSuccessSchemaSchema,
} from '../models/conversationsRenameSuccessSchema.js';
import {
  ConversationsRepliesSuccessSchema,
  conversationsRepliesSuccessSchemaSchema,
} from '../models/conversationsRepliesSuccessSchema.js';
import {
  ConversationsSetPurposeSuccessSchema,
  conversationsSetPurposeSuccessSchemaSchema,
} from '../models/conversationsSetPurposeSuccessSchema.js';
import {
  ConversationsSetTopicSuccessSchema,
  conversationsSetTopicSuccessSchemaSchema,
} from '../models/conversationsSetTopicSuccessSchema.js';
import {
  ConversationsUnarchiveSuccessSchema,
  conversationsUnarchiveSuccessSchemaSchema,
} from '../models/conversationsUnarchiveSuccessSchema.js';
import { boolean, number, optional, string } from '../schema.js';
import { BaseApi } from './baseApi.js';
import { ConversationsArchiveErrorSchemaError } from '../errors/conversationsArchiveErrorSchemaError.js';
import { ConversationsCloseErrorSchemaError } from '../errors/conversationsCloseErrorSchemaError.js';
import { ConversationsCreateErrorSchemaError } from '../errors/conversationsCreateErrorSchemaError.js';
import { ConversationsHistoryErrorSchemaError } from '../errors/conversationsHistoryErrorSchemaError.js';
import { ConversationsInfoErrorSchemaError } from '../errors/conversationsInfoErrorSchemaError.js';
import { ConversationsInviteErrorSchema1Error } from '../errors/conversationsInviteErrorSchema1Error.js';
import { ConversationsJoinErrorSchemaError } from '../errors/conversationsJoinErrorSchemaError.js';
import { ConversationsKickErrorSchemaError } from '../errors/conversationsKickErrorSchemaError.js';
import { ConversationsLeaveErrorSchemaError } from '../errors/conversationsLeaveErrorSchemaError.js';
import { ConversationsListErrorSchemaError } from '../errors/conversationsListErrorSchemaError.js';
import { ConversationsMarkErrorSchemaError } from '../errors/conversationsMarkErrorSchemaError.js';
import { ConversationsMembersErrorSchemaError } from '../errors/conversationsMembersErrorSchemaError.js';
import { ConversationsOpenErrorSchemaError } from '../errors/conversationsOpenErrorSchemaError.js';
import { ConversationsRenameErrorSchemaError } from '../errors/conversationsRenameErrorSchemaError.js';
import { ConversationsRepliesErrorSchemaError } from '../errors/conversationsRepliesErrorSchemaError.js';
import { ConversationsSetPurposeErrorSchemaError } from '../errors/conversationsSetPurposeErrorSchemaError.js';
import { ConversationsSetTopicErrorSchemaError } from '../errors/conversationsSetTopicErrorSchemaError.js';
import { ConversationsUnarchiveErrorSchemaError } from '../errors/conversationsUnarchiveErrorSchemaError.js';

export class ConversationsApi extends BaseApi {
  /**
   * Archives a conversation.
   *
   * @param token        Authentication token. Requires scope: `conversations:write`
   * @param channel      ID of conversation to archive
   * @return Response from the API call
   */
  async conversationsArchive(
    token?: string,
    channel?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsArchiveSuccessSchema>> {
    const req = this.createRequest('POST', '/conversations.archive');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({ channel: mapped.channel });
    req.defaultToError(
      ConversationsArchiveErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      conversationsArchiveSuccessSchemaSchema,
      requestOptions
    );
  }

  /**
   * Closes a direct message or multi-person direct message.
   *
   * @param token        Authentication token. Requires scope: `conversations:write`
   * @param channel      Conversation to close.
   * @return Response from the API call
   */
  async conversationsClose(
    token?: string,
    channel?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsCloseSuccessSchema>> {
    const req = this.createRequest('POST', '/conversations.close');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({ channel: mapped.channel });
    req.defaultToError(
      ConversationsCloseErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      conversationsCloseSuccessSchemaSchema,
      requestOptions
    );
  }

  /**
   * Initiates a public or private channel-based conversation
   *
   * @param token        Authentication token. Requires scope: `conversations:write`
   * @param name         Name of the public or private channel to create
   * @param isPrivate    Create a private channel instead of a public one
   * @return Response from the API call
   */
  async conversationsCreate(
    token?: string,
    name?: string,
    isPrivate?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsCreateSuccessSchema>> {
    const req = this.createRequest('POST', '/conversations.create');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      name: [name, optional(string())],
      isPrivate: [isPrivate, optional(boolean())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({ name: mapped.name, is_private: mapped.isPrivate });
    req.defaultToError(
      ConversationsCreateErrorSchemaError,
      'Typical error response when name already in use'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      conversationsCreateSuccessSchemaSchema,
      requestOptions
    );
  }

  /**
   * Fetches a conversation's history of messages and events.
   *
   * @param token        Authentication token. Requires scope: `conversations:history`
   * @param channel      Conversation ID to fetch history for.
   * @param latest       End of time range of messages to include in results.
   * @param oldest       Start of time range of messages to include in results.
   * @param inclusive    Include messages with latest or oldest timestamp in results only when either
   *                                timestamp is specified.
   * @param limit        The maximum number of items to return. Fewer than the requested number of items
   *                                may be returned, even if the end of the users list hasn't been reached.
   * @param cursor       Paginate through collections of data by setting the `cursor` parameter to a
   *                                `next_cursor` attribute returned by a previous request's `response_metadata`.
   *                                Default value fetches the first "page" of the collection. See
   *                                [pagination](/docs/pagination) for more detail.
   * @return Response from the API call
   */
  async conversationsHistory(
    token?: string,
    channel?: string,
    latest?: number,
    oldest?: number,
    inclusive?: boolean,
    limit?: number,
    cursor?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsHistorySuccessSchema>> {
    const req = this.createRequest('GET', '/conversations.history');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
      latest: [latest, optional(number())],
      oldest: [oldest, optional(number())],
      inclusive: [inclusive, optional(boolean())],
      limit: [limit, optional(number())],
      cursor: [cursor, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.query('token', mapped.token);
    req.query('channel', mapped.channel);
    req.query('latest', mapped.latest);
    req.query('oldest', mapped.oldest);
    req.query('inclusive', mapped.inclusive);
    req.query('limit', mapped.limit);
    req.query('cursor', mapped.cursor);
    req.defaultToError(
      ConversationsHistoryErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      conversationsHistorySuccessSchemaSchema,
      requestOptions
    );
  }

  /**
   * Retrieve information about a conversation.
   *
   * @param token               Authentication token. Requires scope: `conversations:read`
   * @param channel             Conversation ID to learn more about
   * @param includeLocale       Set this to `true` to receive the locale for this conversation. Defaults to
   *                                       `false`
   * @param includeNumMembers   Set to `true` to include the member count for the specified conversation.
   *                                       Defaults to `false`
   * @return Response from the API call
   */
  async conversationsInfo(
    token?: string,
    channel?: string,
    includeLocale?: boolean,
    includeNumMembers?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsInfoSuccessSchema>> {
    const req = this.createRequest('GET', '/conversations.info');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
      includeLocale: [includeLocale, optional(boolean())],
      includeNumMembers: [includeNumMembers, optional(boolean())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.query('token', mapped.token);
    req.query('channel', mapped.channel);
    req.query('include_locale', mapped.includeLocale);
    req.query('include_num_members', mapped.includeNumMembers);
    req.defaultToError(
      ConversationsInfoErrorSchemaError,
      'Typical error response when a channel cannot be found'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(conversationsInfoSuccessSchemaSchema, requestOptions);
  }

  /**
   * Invites users to a channel.
   *
   * @param token        Authentication token. Requires scope: `conversations:write`
   * @param channel      The ID of the public or private channel to invite user(s) to.
   * @param users        A comma separated list of user IDs. Up to 1000 users may be listed.
   * @return Response from the API call
   */
  async conversationsInvite(
    token?: string,
    channel?: string,
    users?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsInviteErrorSchema>> {
    const req = this.createRequest('POST', '/conversations.invite');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
      users: [users, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({ channel: mapped.channel, users: mapped.users });
    req.defaultToError(
      ConversationsInviteErrorSchema1Error,
      'Typical error response when an invite is attempted on a conversation type that does not support it'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(conversationsInviteErrorSchemaSchema, requestOptions);
  }

  /**
   * Joins an existing conversation.
   *
   * @param token        Authentication token. Requires scope: `channels:write`
   * @param channel      ID of conversation to join
   * @return Response from the API call
   */
  async conversationsJoin(
    token?: string,
    channel?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsJoinSuccessSchema>> {
    const req = this.createRequest('POST', '/conversations.join');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({ channel: mapped.channel });
    req.defaultToError(
      ConversationsJoinErrorSchemaError,
      'Typical error response if the conversation is archived and cannot be joined'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(conversationsJoinSuccessSchemaSchema, requestOptions);
  }

  /**
   * Removes a user from a conversation.
   *
   * @param token        Authentication token. Requires scope: `conversations:write`
   * @param channel      ID of conversation to remove user from.
   * @param user         User ID to be removed.
   * @return Response from the API call
   */
  async conversationsKick(
    token?: string,
    channel?: string,
    user?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsKickSuccessSchema>> {
    const req = this.createRequest('POST', '/conversations.kick');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
      user: [user, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({ channel: mapped.channel, user: mapped.user });
    req.defaultToError(
      ConversationsKickErrorSchemaError,
      'Typical error response when you attempt to kick yourself from a channel'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(conversationsKickSuccessSchemaSchema, requestOptions);
  }

  /**
   * Leaves a conversation.
   *
   * @param token        Authentication token. Requires scope: `conversations:write`
   * @param channel      Conversation to leave
   * @return Response from the API call
   */
  async conversationsLeave(
    token?: string,
    channel?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsLeaveSuccessSchema>> {
    const req = this.createRequest('POST', '/conversations.leave');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({ channel: mapped.channel });
    req.defaultToError(
      ConversationsLeaveErrorSchemaError,
      'Typical error response when attempting to leave a workspace\'s "general" channel'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      conversationsLeaveSuccessSchemaSchema,
      requestOptions
    );
  }

  /**
   * Lists all channels in a Slack team.
   *
   * @param token            Authentication token. Requires scope: `conversations:read`
   * @param excludeArchived  Set to `true` to exclude archived channels from the list
   * @param types            Mix and match channel types by providing a comma-separated list of any
   *                                    combination of `public_channel`, `private_channel`, `mpim`, `im`
   * @param limit            The maximum number of items to return. Fewer than the requested number of
   *                                    items may be returned, even if the end of the list hasn't been reached. Must be
   *                                    an integer no larger than 1000.
   * @param cursor           Paginate through collections of data by setting the `cursor` parameter to a
   *                                    `next_cursor` attribute returned by a previous request's `response_metadata`.
   *                                    Default value fetches the first "page" of the collection. See
   *                                    [pagination](/docs/pagination) for more detail.
   * @return Response from the API call
   */
  async conversationsList(
    token?: string,
    excludeArchived?: boolean,
    types?: string,
    limit?: number,
    cursor?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsListSuccessSchema>> {
    const req = this.createRequest('GET', '/conversations.list');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      excludeArchived: [excludeArchived, optional(boolean())],
      types: [types, optional(string())],
      limit: [limit, optional(number())],
      cursor: [cursor, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.query('token', mapped.token);
    req.query('exclude_archived', mapped.excludeArchived);
    req.query('types', mapped.types);
    req.query('limit', mapped.limit);
    req.query('cursor', mapped.cursor);
    req.defaultToError(
      ConversationsListErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(conversationsListSuccessSchemaSchema, requestOptions);
  }

  /**
   * Sets the read cursor in a channel.
   *
   * @param token        Authentication token. Requires scope: `conversations:write`
   * @param channel      Channel or conversation to set the read cursor for.
   * @param ts           Unique identifier of message you want marked as most recently seen in this
   *                               conversation.
   * @return Response from the API call
   */
  async conversationsMark(
    token?: string,
    channel?: string,
    ts?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsMarkSuccessSchema>> {
    const req = this.createRequest('POST', '/conversations.mark');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
      ts: [ts, optional(number())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({ channel: mapped.channel, ts: mapped.ts });
    req.defaultToError(
      ConversationsMarkErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(conversationsMarkSuccessSchemaSchema, requestOptions);
  }

  /**
   * Retrieve members of a conversation.
   *
   * @param token        Authentication token. Requires scope: `conversations:read`
   * @param channel      ID of the conversation to retrieve members for
   * @param limit        The maximum number of items to return. Fewer than the requested number of items may
   *                               be returned, even if the end of the users list hasn't been reached.
   * @param cursor       Paginate through collections of data by setting the `cursor` parameter to a
   *                               `next_cursor` attribute returned by a previous request's `response_metadata`.
   *                               Default value fetches the first "page" of the collection. See
   *                               [pagination](/docs/pagination) for more detail.
   * @return Response from the API call
   */
  async conversationsMembers(
    token?: string,
    channel?: string,
    limit?: number,
    cursor?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsMembersSuccessSchema>> {
    const req = this.createRequest('GET', '/conversations.members');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
      limit: [limit, optional(number())],
      cursor: [cursor, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.query('token', mapped.token);
    req.query('channel', mapped.channel);
    req.query('limit', mapped.limit);
    req.query('cursor', mapped.cursor);
    req.defaultToError(
      ConversationsMembersErrorSchemaError,
      'Typical error response when an invalid cursor is provided'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      conversationsMembersSuccessSchemaSchema,
      requestOptions
    );
  }

  /**
   * Opens or resumes a direct message or multi-person direct message.
   *
   * @param token        Authentication token. Requires scope: `conversations:write`
   * @param channel      Resume a conversation by supplying an `im` or `mpim`'s ID. Or provide the `users`
   *                                field instead.
   * @param users        Comma separated lists of users. If only one user is included, this creates a 1:1
   *                                DM.  The ordering of the users is preserved whenever a multi-person direct message
   *                                is returned. Supply a `channel` when not supplying `users`.
   * @param returnIm     Boolean, indicates you want the full IM channel definition in the response.
   * @return Response from the API call
   */
  async conversationsOpen(
    token?: string,
    channel?: string,
    users?: string,
    returnIm?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsOpenSuccessSchema>> {
    const req = this.createRequest('POST', '/conversations.open');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
      users: [users, optional(string())],
      returnIm: [returnIm, optional(boolean())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({
      channel: mapped.channel,
      users: mapped.users,
      return_im: mapped.returnIm,
    });
    req.defaultToError(
      ConversationsOpenErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(conversationsOpenSuccessSchemaSchema, requestOptions);
  }

  /**
   * Renames a conversation.
   *
   * @param token        Authentication token. Requires scope: `conversations:write`
   * @param channel      ID of conversation to rename
   * @param name         New name for conversation.
   * @return Response from the API call
   */
  async conversationsRename(
    token?: string,
    channel?: string,
    name?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsRenameSuccessSchema>> {
    const req = this.createRequest('POST', '/conversations.rename');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
      name: [name, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({ channel: mapped.channel, name: mapped.name });
    req.defaultToError(
      ConversationsRenameErrorSchemaError,
      'Typical error response when the calling user is not a member of the conversation'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      conversationsRenameSuccessSchemaSchema,
      requestOptions
    );
  }

  /**
   * Retrieve a thread of messages posted to a conversation
   *
   * @param token        Authentication token. Requires scope: `conversations:history`
   * @param channel      Conversation ID to fetch thread from.
   * @param ts           Unique identifier of a thread's parent message. `ts` must be the timestamp of an
   *                                existing message with 0 or more replies. If there are no replies then just the
   *                                single message referenced by `ts` will return - it is just an ordinary, unthreaded
   *                                message.
   * @param latest       End of time range of messages to include in results.
   * @param oldest       Start of time range of messages to include in results.
   * @param inclusive    Include messages with latest or oldest timestamp in results only when either
   *                                timestamp is specified.
   * @param limit        The maximum number of items to return. Fewer than the requested number of items
   *                                may be returned, even if the end of the users list hasn't been reached.
   * @param cursor       Paginate through collections of data by setting the `cursor` parameter to a
   *                                `next_cursor` attribute returned by a previous request's `response_metadata`.
   *                                Default value fetches the first "page" of the collection. See
   *                                [pagination](/docs/pagination) for more detail.
   * @return Response from the API call
   */
  async conversationsReplies(
    token?: string,
    channel?: string,
    ts?: number,
    latest?: number,
    oldest?: number,
    inclusive?: boolean,
    limit?: number,
    cursor?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsRepliesSuccessSchema>> {
    const req = this.createRequest('GET', '/conversations.replies');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
      ts: [ts, optional(number())],
      latest: [latest, optional(number())],
      oldest: [oldest, optional(number())],
      inclusive: [inclusive, optional(boolean())],
      limit: [limit, optional(number())],
      cursor: [cursor, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.query('token', mapped.token);
    req.query('channel', mapped.channel);
    req.query('ts', mapped.ts);
    req.query('latest', mapped.latest);
    req.query('oldest', mapped.oldest);
    req.query('inclusive', mapped.inclusive);
    req.query('limit', mapped.limit);
    req.query('cursor', mapped.cursor);
    req.defaultToError(
      ConversationsRepliesErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      conversationsRepliesSuccessSchemaSchema,
      requestOptions
    );
  }

  /**
   * Sets the purpose for a conversation.
   *
   * @param token        Authentication token. Requires scope: `conversations:write`
   * @param channel      Conversation to set the purpose of
   * @param purpose      A new, specialer purpose
   * @return Response from the API call
   */
  async conversationsSetPurpose(
    token?: string,
    channel?: string,
    purpose?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsSetPurposeSuccessSchema>> {
    const req = this.createRequest('POST', '/conversations.setPurpose');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
      purpose: [purpose, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({ channel: mapped.channel, purpose: mapped.purpose });
    req.defaultToError(
      ConversationsSetPurposeErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      conversationsSetPurposeSuccessSchemaSchema,
      requestOptions
    );
  }

  /**
   * Sets the topic for a conversation.
   *
   * @param token        Authentication token. Requires scope: `conversations:write`
   * @param channel      Conversation to set the topic of
   * @param topic        The new topic string. Does not support formatting or linkification.
   * @return Response from the API call
   */
  async conversationsSetTopic(
    token?: string,
    channel?: string,
    topic?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsSetTopicSuccessSchema>> {
    const req = this.createRequest('POST', '/conversations.setTopic');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
      topic: [topic, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({ channel: mapped.channel, topic: mapped.topic });
    req.defaultToError(
      ConversationsSetTopicErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      conversationsSetTopicSuccessSchemaSchema,
      requestOptions
    );
  }

  /**
   * Reverses conversation archival.
   *
   * @param token        Authentication token. Requires scope: `conversations:write`
   * @param channel      ID of conversation to unarchive
   * @return Response from the API call
   */
  async conversationsUnarchive(
    token?: string,
    channel?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConversationsUnarchiveSuccessSchema>> {
    const req = this.createRequest('POST', '/conversations.unarchive');
    const mapped = req.prepareArgs({
      token: [token, optional(string())],
      channel: [channel, optional(string())],
    });
    req.header('Content-Type', 'application/x-www-form-urlencoded');
    req.header('token', mapped.token);
    req.form({ channel: mapped.channel });
    req.defaultToError(
      ConversationsUnarchiveErrorSchemaError,
      'Typical error response'
    );
    req.authenticate([{ slackAuth: true }]);
    return req.callAsJson(
      conversationsUnarchiveSuccessSchemaSchema,
      requestOptions
    );
  }
}
